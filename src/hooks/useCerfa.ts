// src/hooks/useCerfa.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
import { QueryKey, useMutation, UseMutationOptions, useQuery, UseQueryOptions } from "@tanstack/react-query";
import api from "../api/axios"; // ‚úÖ ton axios custom avec refresh token int√©gr√©
import {
  CerfaContrat,
  CerfaContratCreate,
  CerfaContratUpdate,
  CerfaQueryParams,
  DRFListResponse,
} from "../types/cerfa";

/* ----------------------------------------
   üîë Query Keys
----------------------------------------- */
export const CERFA_QK = {
  all: ["cerfa-contrats"] as const,
  list: (params?: CerfaQueryParams) => ["cerfa-contrats", "list", params] as const,
  detail: (id: number | string) => ["cerfa-contrats", "detail", id] as const,
  latest: (candidatId: number | string) => ["cerfa-contrats", "latest", candidatId] as const,
  byCandidat: (candidatId: number | string, params?: CerfaQueryParams) =>
    ["cerfa-contrats", "by-candidat", candidatId, params] as const,
  autoGenerated: (params?: CerfaQueryParams) =>
    ["cerfa-contrats", "auto-generated", params] as const,
};

/* ----------------------------------------
   üõ†Ô∏è Helpers
----------------------------------------- */
const toQueryString = (params: Record<string, any> = {}) =>
  Object.entries(params)
    .filter(([, v]) => v !== undefined && v !== null && v !== "")
    .map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`)
    .join("&");

export const downloadBlob = (blob: Blob, filename: string) => {
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
};

/* ----------------------------------------
   üì° Services (appel API bruts)
----------------------------------------- */
const basePath = "/cerfa-contrats/";

export const cerfaService = {
list: async (params?: CerfaQueryParams): Promise<DRFListResponse<CerfaContrat>> => {
  const qs = toQueryString(params ?? {});
  const { data } = await api.get(`${basePath}${qs ? `?${qs}` : ""}`);

  // ‚úÖ compatibilit√© avec ton backend qui renvoie success/message/data
  return data.data ?? data;
}, 

  retrieve: async (id: number | string): Promise<CerfaContrat> => {
    const { data } = await api.get<CerfaContrat>(`${basePath}${id}/`);
    return data;
  },

  create: async (payload: CerfaContratCreate): Promise<CerfaContrat> => {
    const { data } = await api.post<CerfaContrat>(basePath, payload);
    return data;
  },

  update: async (id: number | string, payload: CerfaContratUpdate): Promise<CerfaContrat> => {
    const { data } = await api.put<CerfaContrat>(`${basePath}${id}/`, payload);
    return data;
  },

  patch: async (id: number | string, payload: CerfaContratUpdate): Promise<CerfaContrat> => {
    const { data } = await api.patch<CerfaContrat>(`${basePath}${id}/`, payload);
    return data;
  },

  delete: async (id: number | string): Promise<void> => {
    await api.delete(`${basePath}${id}/`);
  },

  generatePdf: async (id: number | string): Promise<{ id: number; pdf_url: string | null; message: string }> => {
    const { data } = await api.post<{ id: number; pdf_url: string | null; message: string }>(
      `${basePath}${id}/generate-pdf/`
    );
    return data;
  },

  downloadPdf: async (id: number | string): Promise<Blob> => {
    const res = await api.get(`${basePath}${id}/download-pdf/`, {
      responseType: "blob",
    });
    return res.data as Blob;
  },

  latestByCandidat: async (candidatId: number | string): Promise<CerfaContrat> => {
    const { data } = await api.get<CerfaContrat>(`${basePath}latest/?candidat=${candidatId}`);
    return data;
  },

  listAutoGenerated: async (params?: CerfaQueryParams): Promise<DRFListResponse<CerfaContrat>> => {
    const qs = toQueryString(params ?? {});
    const { data } = await api.get<DRFListResponse<CerfaContrat>>(
      `${basePath}auto-generated/${qs ? `?${qs}` : ""}`
    );
    return data;
  },

  listByCandidat: async (
    candidatId: number | string,
    params?: CerfaQueryParams
  ): Promise<DRFListResponse<CerfaContrat>> => {
    const qs = toQueryString(params ?? {});
    const { data } = await api.get<DRFListResponse<CerfaContrat>>(
      `${basePath}by-candidat/${candidatId}/${qs ? `?${qs}` : ""}`
    );
    return data;
  },
};

/* ----------------------------------------
   ü™ù Hooks React Query
----------------------------------------- */

// LIST
export const useCerfaList = (
  params?: CerfaQueryParams,
  options?: UseQueryOptions<DRFListResponse<CerfaContrat>, any, DRFListResponse<CerfaContrat>, QueryKey>
) =>
  useQuery({
    queryKey: CERFA_QK.list(params),
    queryFn: () => cerfaService.list(params),
    ...options,
  });

// DETAIL
export const useCerfaDetail = (
  id: number | string,
  options?: UseQueryOptions<CerfaContrat, any, CerfaContrat, QueryKey>
) =>
  useQuery({
    queryKey: CERFA_QK.detail(id),
    queryFn: () => cerfaService.retrieve(id),
    enabled: !!id,
    ...options,
  });

// CREATE
export const useCerfaCreate = (
  options?: UseMutationOptions<CerfaContrat, any, CerfaContratCreate>
) =>
  useMutation({
    mutationFn: async (payload) => {
      try {
        const data = await cerfaService.create(payload);
        return data;
      } catch (err: any) {
        console.error("‚ùå Erreur lors de la cr√©ation du CERFA:", err);
        throw err;
      }
    },
    ...options,
  });

// UPDATE (PUT)
export const useCerfaUpdate = (
  id: number | string,
  options?: UseMutationOptions<CerfaContrat, any, CerfaContratUpdate | CerfaContratCreate>
) =>
  useMutation({
    mutationFn: async (payload) => {
      try {
        const data = await cerfaService.update(id, payload);
        return data;
      } catch (err: any) {
        console.error("‚ùå Erreur lors de la mise √† jour du CERFA:", err);
        // Si le backend renvoie un 400 avec `missing_fields`, on laisse passer le body pour traitement front
        if (err?.response?.status === 400 && err?.response?.data) {
          throw err;
        }
        throw err;
      }
    },
    ...options,
  });
 

// PATCH
export const useCerfaPatch = (
  id: number | string,
  options?: UseMutationOptions<CerfaContrat, any, CerfaContratUpdate>
) =>
  useMutation({
    mutationFn: (payload) => cerfaService.patch(id, payload),
    ...options,
  });

// DELETE
export const useCerfaDelete = (
  options?: UseMutationOptions<void, any, number | string>
) =>
  useMutation({
    mutationFn: (id) => cerfaService.delete(id),
    ...options,
  });

// GENERATE PDF
export const useCerfaGeneratePdf = (
  id: number | string,
  options?: UseMutationOptions<{ id: number; pdf_url: string | null; message: string }, any, void>
) =>
  useMutation({
    mutationFn: () => cerfaService.generatePdf(id),
    ...options,
  });

// DOWNLOAD PDF (renvoie le blob ‚Äî utilises downloadBlob pour sauvegarder)
export const useCerfaDownloadPdf = (
  options?: UseMutationOptions<Blob, any, number | string>
) =>
  useMutation({
    mutationFn: (id: number | string) => cerfaService.downloadPdf(id),
    ...options,
  }); 

// LATEST BY CANDIDAT
export const useCerfaLatestByCandidat = (
  candidatId: number | string,
  options?: UseQueryOptions<CerfaContrat, any, CerfaContrat, QueryKey>
) =>
  useQuery({
    queryKey: CERFA_QK.latest(candidatId),
    queryFn: () => cerfaService.latestByCandidat(candidatId),
    enabled: !!candidatId,
    ...options,
  });

// LIST AUTO-GENERATED
export const useCerfaAutoGenerated = (
  params?: CerfaQueryParams,
  options?: UseQueryOptions<DRFListResponse<CerfaContrat>, any, DRFListResponse<CerfaContrat>, QueryKey>
) =>
  useQuery({
    queryKey: CERFA_QK.autoGenerated(params),
    queryFn: () => cerfaService.listAutoGenerated(params),
    ...options,
  });

// LIST BY CANDIDAT
export const useCerfaByCandidat = (
  candidatId: number | string,
  params?: CerfaQueryParams,
  options?: UseQueryOptions<DRFListResponse<CerfaContrat>, any, DRFListResponse<CerfaContrat>, QueryKey>
) =>
  useQuery({
    queryKey: CERFA_QK.byCandidat(candidatId, params),
    queryFn: () => cerfaService.listByCandidat(candidatId, params),
    enabled: !!candidatId,
    ...options,
  });
 